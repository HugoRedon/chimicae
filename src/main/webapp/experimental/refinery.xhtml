<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:ui="http://java.sun.com/jsf/facelets"
      xmlns:f="http://java.sun.com/jsf/core"
      xmlns:h="http://java.sun.com/jsf/html">

	<h:head>
		<title>Experimental</title>        
        <style>
            body {
                font-family: Monospace;
                background-color: #f0f0f0;
                margin: 0px;
                overflow: hidden;
            }
        </style>
		<h:outputScript name="js/ServletCall.js" />
	</h:head>
	
	<h:body>
		<script >

			//hello();
		</script>
		 <h:outputScript name="js/three.min.js"  />
        <h:outputScript name="js/controls/TrackballControls.js"  />
        <h:outputScript name="js/Stats.js"  />
        <h:outputScript name="js/THREEx.KeyboardState.js"  />
        <script>
      //<![CDATA[
            var container, stats;
            var camera, controls, scene, projector, renderer;
            var objects = [], plane;
            var record;
            var cylinder;
            var info;
            var heatExchanger;
            var pipeLine;
            var pipeLineGeom;
            var lastCylinderPosition;
            var keyboard = new THREEx.KeyboardState();

            var mouse = new THREE.Vector2(),
            offset = new THREE.Vector3(),
            INTERSECTED, SELECTED;
            var sel;


            var doneLoading = false;
            
            init();
            animate();


            function loadCylinder(){
                var cyl = new THREE.CylinderGeometry( 100,100, 100, 32 );
                var tankMaterial = new THREE.MeshBasicMaterial( {color: 0x222222} );
                cylinder = new THREE.Mesh( cyl, tankMaterial );
                cylinder.rotation.x=Math.PI/2;
                cylinder.position.x=900;
                cylinder.position.y=900;
                cylinder.position.z=50;

                cylinder.userData = {name:"Tanque"};
                scene.add( cylinder );

                objects.push(cylinder);
             }

            function loadHeatExchanger(){
            	var loader = new THREE.JSONLoader();
				//alert("start loading");
				console.log("start loading");
                loader.load( "models/simple-heat-exchanger.js", function( geometry ) {
                	heatExchanger = new THREE.Mesh( geometry, new THREE.MeshNormalMaterial() );
                	heatExchanger.scale.set( 20, 20, 20 );
                	heatExchanger.position.y = 150;
                	heatExchanger.position.x = 0;
                	heatExchanger.rotation.x = Math.PI/2;
                	 heatExchanger.castShadow = true;
                     heatExchanger.receiveShadow = true;
                	heatExchanger.userData={name:"Intercambiador de calor"}
                	
                    scene.add( heatExchanger );
                    //alert("added");




                	 var lineMaterial = new THREE.LineBasicMaterial({
                         color: 0x0000ff
                     });

				     pipeLineGeom = new THREE.Geometry();
				     pipeLineGeom.vertices.push(new THREE.Vector3(
				         heatExchanger.position.x,heatExchanger.position.y,heatExchanger.position.z));
				     
				     pipeLineGeom.vertices.push(new THREE.Vector3(cylinder.position.x,cylinder.position.y,cylinder.position.z));
				
				     var pipeLine = new THREE.Line(pipeLineGeom, lineMaterial);
				     scene.add( pipeLine );
				     objects.push( heatExchanger );
				     doneLoading = true;
                } );
             }

            function init() {

                container = document.createElement( 'div' );
                document.body.appendChild( container );
                
                camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 10000 );
                camera.position.z = 1000;

                controls = new THREE.TrackballControls( camera );

                scene = new THREE.Scene();

                scene.add( new THREE.AmbientLight( 0xfff ) );

                var light = new THREE.SpotLight( 0xffffff, 1.5 );
                light.position.set( 0, 500, 2000 );
                light.castShadow = true;

                light.shadowCameraNear = 200;
                light.shadowCameraFar = camera.far;
                light.shadowCameraFov = 50;

                light.shadowBias = -0.00022;
                light.shadowDarkness = 0.5;

                light.shadowMapWidth = 2048;
                light.shadowMapHeight = 2048;

                scene.add( light );

                 record = new THREE.Mesh( new THREE.PlaneGeometry( 5000, 5000, 8, 8 ), new THREE.MeshBasicMaterial( { color: 0x000022, opacity: 0.25, transparent: false, wireframe: false ,side:THREE.DoubleSide} ) );

                 record.visible=false;
                scene.add(record);
                var geometry = new THREE.BoxGeometry( 40, 40, 40 );


            	loadCylinder();
                

       
 

                

                
            				

                

                

               

                

                for ( var i = 0; i < 2; i ++ ) {

                    var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );

                    object.material.ambient = object.material.color;

                    object.position.x = Math.random() * 1000 - 500;
                    object.position.y = Math.random() * 600 - 300;
                    object.position.z = 20;
                   // object.position.z = Math.random() * 800 - 400;

                    // object.rotation.x = Math.random() * 2 * Math.PI;
                    // object.rotation.y = Math.random() * 2 * Math.PI;
                   // object.rotation.z = Math.random() * 2 * Math.PI;

                    // object.scale.x = Math.random() * 2 + 1;
                    // object.scale.y = Math.random() * 2 + 1;
                   // object.scale.z = Math.random() * 2 + 1;

                    object.castShadow = true;
                    object.receiveShadow = true;
                    scene.add( object );
                    objects.push( object );

                }

                plane = new THREE.Mesh( new THREE.PlaneGeometry( 2000, 2000, 8, 8 ), new THREE.MeshBasicMaterial( { color: 0x000044, opacity: 0.25, transparent: true, wireframe: false ,side:THREE.DoubleSide} ) );
                plane.visible = true;
                scene.add( plane );

                projector = new THREE.Projector();

                renderer = new THREE.WebGLRenderer( { antialias: true } );
                renderer.setClearColor( 0xf0f0f0 );
                renderer.setSize( window.innerWidth, window.innerHeight );
                renderer.sortObjects = false;

                renderer.shadowMapEnabled = true;
                renderer.shadowMapType = THREE.PCFShadowMap;

                container.appendChild( renderer.domElement );

                info = document.createElement( 'div' );
                info.style.position = 'absolute';
                info.style.top = '10px';
                info.style.width = '100%';
                info.style.textAlign = 'center';
                info.innerHTML = '<a href="http://threejs.org" target="_blank">three.js</a> webgl - draggable cubes';
                container.appendChild( info );

                stats = new Stats();
                stats.domElement.style.position = 'absolute';
                stats.domElement.style.top = '0px';
                container.appendChild( stats.domElement );

                renderer.domElement.addEventListener( 'mousemove', onDocumentMouseMove, false );
                renderer.domElement.addEventListener( 'mousedown', onDocumentMouseDown, false );
                renderer.domElement.addEventListener( 'mouseup', onDocumentMouseUp, false );

                //

                window.addEventListener( 'resize', onWindowResize, false );

            }

            function onWindowResize() {

                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();

                renderer.setSize( window.innerWidth, window.innerHeight );

            }

            function onDocumentMouseMove( event ) {

                event.preventDefault();

                mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
                mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

                //

                var vector = new THREE.Vector3( mouse.x, mouse.y, 0.5 );
                projector.unprojectVector( vector, camera );

                var raycaster = new THREE.Raycaster( camera.position, vector.sub( camera.position ).normalize() );


                if ( SELECTED ) {

                    var intersects = raycaster.intersectObject( plane );
                    SELECTED.position.copy( intersects[ 0 ].point.sub( offset ) );
                    return;

                }


                var intersects = raycaster.intersectObjects( objects );

                if ( intersects.length > 0 ) {

                    if ( INTERSECTED != intersects[ 0 ].object ) {

                        if ( INTERSECTED ) INTERSECTED.material.color.setHex( INTERSECTED.currentHex );

                        INTERSECTED = intersects[ 0 ].object;
                        INTERSECTED.currentHex = INTERSECTED.material.color.getHex();

                        record.position.copy( INTERSECTED.position );
                        record.lookAt( camera.position );

                    }

                    container.style.cursor = 'pointer';

                } else {

                    if ( INTERSECTED ) INTERSECTED.material.color.setHex( INTERSECTED.currentHex );

                    INTERSECTED = null;

                    container.style.cursor = 'auto';

                }

            }

            function onDocumentMouseDown( event ) {

                event.preventDefault();

                var vector = new THREE.Vector3( mouse.x, mouse.y, 0.5 );
                projector.unprojectVector( vector, camera );

                var raycaster = new THREE.Raycaster( camera.position, vector.sub( camera.position ).normalize() );

                var intersects = raycaster.intersectObjects( objects );

                if ( intersects.length > 0 ) {

                    controls.enabled = false;

                    SELECTED = intersects[ 0 ].object;
                    sel = SELECTED;

                    var intersects = raycaster.intersectObject( plane );
                    offset.copy( intersects[ 0 ].point ).sub( record.position );

                    container.style.cursor = 'move';

                }

            }

            function onDocumentMouseUp( event ) {

                event.preventDefault();

                controls.enabled = true;

                if ( INTERSECTED ) {

                    record.position.copy( INTERSECTED.position );

                    SELECTED = null;

                }

                container.style.cursor = 'auto';

            }

            //

            function animate() {

                requestAnimationFrame( animate );

                render();
                stats.update();
                update();
            }

            function update(){
                if ( keyboard.pressed("c") ){
                    info.innerHTML="Intercambiador creado";
                }
                if(doneLoading==true){
                    
                }
            }


            function render() {

                controls.update();
                lastCylinderPosition = cylinder.position;

                if( sel ){
                   info.innerHTML = sel.userData.name;
                 };
                
                pipeLineGeom.vertices =[];
                 pipeLineGeom.vertices.push(new THREE.Vector3(
                    heatExchanger.position.x,heatExchanger.position.y,heatExchanger.position.z));
                
                pipeLineGeom.vertices.push(new THREE.Vector3(cylinder.position.x,cylinder.position.y,cylinder.position.z));
                pipeLineGeom.verticesNeedUpdate =true;

                renderer.render( scene, camera );

            }
          //]]>
        </script>
		
		
		
	</h:body>
</html>