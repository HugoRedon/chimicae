<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:ui="http://java.sun.com/jsf/facelets"
      xmlns:f="http://java.sun.com/jsf/core"
      xmlns:h="http://java.sun.com/jsf/html">

	<h:head>
		<title>Experimental</title>        
        <style>
            body {
                font-family: Monospace;
                background-color: #f0f0f0;
                margin: 0px;
                overflow: hidden;
            }
        </style>
		<h:outputScript name="js/ServletCall.js" />
		 <h:outputScript name="js/three.min.js"  />
        <h:outputScript name="js/controls/OrbitControls.js"  />
        <h:outputScript name="js/Stats.js"  />
        <h:outputScript name="js/THREEx.KeyboardState.js"  />
        <h:outputScript name="js/hrr/plant.js"/>
        <h:outputStylesheet name="css/controls.css"/>
	</h:head>
	
	<h:body>
		<script >

			//hello();
		</script>

        <div id="labels" class="menu">
				Propiedad<br/><br/>
				<div class="lbl btn" id="btn_add">Tubería</div>
				<div class="lbl btn" id="btn_sub">Entropía</div>
				<div class="lbl btn" id="btn_rsub">E. Gibbs</div>

				Líneas<br/><br/>
				<div class="lbl btn" id="btn_pressure">Temperatura constante</div>
				<div class="lbl btn" id="btn_tempLines">Presión constante</div>

			</div>
        <script>
      //<![CDATA[
            var container, stats;
            var camera, controls, scene, projector, renderer;
            var plane;
            var record;
            var cylinder;
            var info;
            var heatExchanger;
            var pipeLine;
            var pipeLineGeom;
            var lastCylinderPosition;
            var keyboard = new THREEx.KeyboardState();

            var mouse = new THREE.Vector2(),
            offset = new THREE.Vector3(),
            INTERSECTED, SELECTED;
            var sel;
            var doneLoading = false;



            scene = new THREE.Scene();
            scene.add( new THREE.AmbientLight( 0x555555 ) );
				
			var plant = new Plant(scene);
			//plant.load3dModel();

			init();
			animate();
         	
    		
	function continueFunction (){

		console.log("continue function");
	}

	
            
     function rest(){
         
           
            
                var cyl = new THREE.CylinderGeometry( 100,100, 100, 32 );
                var tankMaterial = new THREE.MeshBasicMaterial( {color: 0x222222} );
                cylinder = new THREE.Mesh( cyl, tankMaterial );
                cylinder.rotation.x=Math.PI/2;
                cylinder.position.x=900;
                cylinder.position.y=900;
                cylinder.position.z=50;

                cylinder.userData = {name:"Tanque"};
               
             

            
            	var loader = new THREE.JSONLoader();
				//alert("start loading");
				console.log("start loading");
                loader.load( "models/simple-heat-exchanger.js", function( geometry ) {
                	heatExchanger = new THREE.MeshPhongMaterial( { 
			            color: 0x000044, 
			            ambient: 0x000044, // should generally match color
			            specular: 0x050505,
			            side: THREE.DoubleSide,
			            shininess: 100
			        } ) ;
                	heatExchanger.scale.set( 20, 20, 20 );
                	heatExchanger.position.y = 150;
                	heatExchanger.position.x = 0;
                	heatExchanger.rotation.x = Math.PI/2;
                	 heatExchanger.castShadow = true;
                     heatExchanger.receiveShadow = true;
                	heatExchanger.userData={name:"Intercambiador de calor"}


                	 init();
	            	animate();

	            	//alert("added");
                    scene.add( heatExchanger );
                    




                	 var lineMaterial = new THREE.LineBasicMaterial({
                         color: 0x0000ff
                     });

				     pipeLineGeom = new THREE.Geometry();
				     pipeLineGeom.vertices.push(new THREE.Vector3(
				         heatExchanger.position.x,heatExchanger.position.y,heatExchanger.position.z));
				     
				     pipeLineGeom.vertices.push(new THREE.Vector3(cylinder.position.x,cylinder.position.y,cylinder.position.z));
				
				     var pipeLine = new THREE.Line(pipeLineGeom, lineMaterial);
				     scene.add( pipeLine );
				     plant.objects.push( heatExchanger );
				     doneLoading = true;
				    

                } );

                scene.add( cylinder );

                plant.objects.push(cylinder);
     }

            function init() {

                container = document.createElement( 'div' );
                document.body.appendChild( container );
                
                camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 10000 );
                camera.position.z = 1000;
                camera.up = new THREE.Vector3( 0, 0, 1 );

                controls = new THREE.OrbitControls( camera );

                controls.maxPolarAngle = Math.PI/2; 

                var light = new THREE.SpotLight( 0xffffff, 1.5 );
                light.position.set( 0, 500, 2000 );
                light.castShadow = true;
/* 
                light.shadowCameraNear = 200;
                light.shadowCameraFar = camera.far;
                light.shadowCameraFov = 50;

                light.shadowBias = -0.00022;
                light.shadowDarkness = 0.5;

                light.shadowMapWidth = 2048;
                light.shadowMapHeight = 2048; */

                scene.add( light );

                 record = new THREE.Mesh( new THREE.PlaneGeometry( 12000, 12000, 8, 8 ), new THREE.MeshBasicMaterial( { color: 0x000022, opacity: 0.25, transparent: false, wireframe: false ,side:THREE.DoubleSide} ) );

                 record.visible=false;
                scene.add(record);
                var geometry = new THREE.BoxGeometry( 40, 40, 40 );


            	
                

       			
                

                for ( var i = 0; i < 2; i ++ ) {

                    var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );

                    object.material.ambient = object.material.color;

                    object.position.x = Math.random() * 1000 - 500;
                    object.position.y = Math.random() * 600 - 300;
                    object.position.z = 20;
                   // object.position.z = Math.random() * 800 - 400;

                    // object.rotation.x = Math.random() * 2 * Math.PI;
                    // object.rotation.y = Math.random() * 2 * Math.PI;
                   // object.rotation.z = Math.random() * 2 * Math.PI;

                    // object.scale.x = Math.random() * 2 + 1;
                    // object.scale.y = Math.random() * 2 + 1;
                   // object.scale.z = Math.random() * 2 + 1;

                    object.castShadow = true;
                    object.receiveShadow = true;
                    //scene.add( object );
                   // plant.objects.push( object );

                }
                
                plane = new THREE.Mesh( new THREE.PlaneGeometry( 10000, 10000, 8, 8 ),
                         new THREE.MeshBasicMaterial( { color: 0xdddddd, opacity: 0.25, wireframe: false ,side:THREE.DoubleSide} ) );
                plane.visible = true;
                plane.receiveShadow = true;
                scene.add( plane );

                projector = new THREE.Projector();

                renderer = new THREE.WebGLRenderer( { antialias: true } );
                //renderer.setClearColor( 0xf0f0f0 );
                renderer.setSize( window.innerWidth, window.innerHeight );
                renderer.sortObjects = false;

                renderer.shadowMapEnabled = true;
                renderer.shadowMapType = THREE.PCFShadowMap;

                container.appendChild( renderer.domElement );

                info = document.createElement( 'div' );
                info.style.position = 'absolute';
                info.style.top = '10px';
                info.style.color='#ffffff';
                info.style.width = '100%';
                info.style.textAlign = 'center';
                info.innerHTML = '';
                container.appendChild( info );

                stats = new Stats();
                stats.domElement.style.position = 'absolute';
                stats.domElement.style.top = '0px';                
			    stats.domElement.style.right='0px';
			    stats.domElement.style.zIndex = 100;
                container.appendChild( stats.domElement );

                renderer.domElement.addEventListener( 'mousemove', onDocumentMouseMove, false );
                renderer.domElement.addEventListener( 'mousedown', onDocumentMouseDown, false );
                renderer.domElement.addEventListener( 'mouseup', onDocumentMouseUp, false );

                //

                window.addEventListener( 'resize', onWindowResize, false );
                eventListeners();

            }

            function eventListeners(){
               	var el = document.getElementById("btn_add");
               	el.addEventListener('click', function(){

						plant.draw();
                   	});
            }

            function onWindowResize() {

                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();

                renderer.setSize( window.innerWidth, window.innerHeight );

            }

            function onDocumentMouseMove( event ) {

                event.preventDefault();

                mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
                mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

                //

                var vector = new THREE.Vector3( mouse.x, mouse.y, 0.5 );
                projector.unprojectVector( vector, camera );

                var raycaster = new THREE.Raycaster( camera.position, vector.sub( camera.position ).normalize() );


                if ( SELECTED ) {

                    var intersects = raycaster.intersectObject( plane );
                    SELECTED.position.copy( intersects[ 0 ].point.sub( offset ) );
                   
                    return;

                }


                var intersects = raycaster.intersectObjects( plant.objects );

                if ( intersects.length > 0 ) {

                    if ( INTERSECTED != intersects[ 0 ].object ) {

                        if ( INTERSECTED ) INTERSECTED.material.color.setHex( INTERSECTED.currentHex );

                        INTERSECTED = intersects[ 0 ].object;
                        INTERSECTED.currentHex = INTERSECTED.material.color.getHex();

                        record.position.copy( INTERSECTED.position );
                        record.lookAt( camera.position );

                    }

                    container.style.cursor = 'pointer';

                } else {

                    if ( INTERSECTED ) INTERSECTED.material.color.setHex( INTERSECTED.currentHex );

                    INTERSECTED = null;

                    container.style.cursor = 'auto';

                }

            }

            function onDocumentMouseDown( event ) {

                event.preventDefault();

                var vector = new THREE.Vector3( mouse.x, mouse.y, 0.5 );
                projector.unprojectVector( vector, camera );

                var raycaster = new THREE.Raycaster( camera.position, vector.sub( camera.position ).normalize() );

                var intersects = raycaster.intersectObjects( plant.objects );

                if ( intersects.length > 0 ) {

                    controls.enabled = false;

                    SELECTED = intersects[ 0 ].object;
                    sel = SELECTED;

                    var intersects = raycaster.intersectObject( plane );
                    offset.copy( intersects[ 0 ].point ).sub( record.position );

                    container.style.cursor = 'move';

                }

            }

            function onDocumentMouseUp( event ) {

                event.preventDefault();

                controls.enabled = true;

                if ( INTERSECTED ) {

                    record.position.copy( INTERSECTED.position );
                    
                    plant.drawTubes();
                    SELECTED = null;

                }

                container.style.cursor = 'auto';

            }

            //

            function animate() {

                requestAnimationFrame( animate );

                render();
                stats.update();
                update();
            }

            function update(){
                if ( keyboard.pressed("c") ){
                    info.innerHTML="Intercambiador creado";
                }
                if(doneLoading==true){
                    
                }
            }


            function render() {

                controls.update();
                //lastCylinderPosition = cylinder.position;

                if( sel ){
                   info.innerHTML = sel.userData.name;
                 };
                
                /* pipeLineGeom.vertices =[];
                 pipeLineGeom.vertices.push(new THREE.Vector3(
                    heatExchanger.position.x,heatExchanger.position.y,heatExchanger.position.z));
                
                pipeLineGeom.vertices.push(new THREE.Vector3(cylinder.position.x,cylinder.position.y,cylinder.position.z));
                pipeLineGeom.verticesNeedUpdate =true;
 */
                renderer.render( scene, camera );

            }
          //]]>
        </script>
		
		
		
	</h:body>
</html>