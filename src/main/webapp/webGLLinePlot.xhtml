<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:ui="http://java.sun.com/jsf/facelets"
      xmlns:f="http://java.sun.com/jsf/core"
      xmlns:h="http://java.sun.com/jsf/html">

	
	<h:head>
		<title>Chimicae</title>
		<meta charset="utf-8"/>
	 	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"/>
		 
		<h:outputStylesheet name="css/style.css"  />
		
		<h:outputScript name="js/three.min.js"  />
		<h:outputScript name="js/Detector.js"  />
		<h:outputScript name="js/Stats.js"  />
		 <!-- <h:outputScript name="js/controls/TrackballControls.js"  /> --> 
		<h:outputScript name="js/controls/OrbitControls.js"  /> 
		<h:outputScript name="js/THREEx.KeyboardState.js"  />
		<h:outputScript name="js/THREEx.FullScreen.js"  />
		<h:outputScript name="js/THREEx.WindowResize.js"  />
		<h:outputScript name="fonts/ubuntu_light.typeface.js"/>
		<h:outputStylesheet name="css/controls.css"/>
		
	</h:head> 
	<h:body> 
		<ui:insert name="content">
			<div id="labels" class="menu">
				Propiedad<br/><br/>
				<div class="lbl btn" id="btn_add">Entalpía</div>
				<div class="lbl btn" id="btn_sub">Entropía</div>
				<div class="lbl btn" id="btn_rsub">E. Gibbs</div>

				Líneas<br/><br/>
				<div class="lbl btn" id="btn_pressure">Presión</div>
				<div class="lbl btn" id="btn_tempLines">Temperatura</div>
	<!-- 
				Labels<br/><br/>
				<div class="lbl" id="lbl_src">Source</div>
				<div class="lbl" id="lbl_dst">Destination</div>  -->
			</div>
			 <div id="ThreeJS" style="position: absolute; left:0px; top:0px" ></div>
			 <div id="info"> Gráfico</div>
		    <script>
		  //<![CDATA[
		    var container, scene, camera, renderer, controls, stats;
		    var keyboard = new THREEx.KeyboardState();
		    var clock = new THREE.Clock();
		    // custom global variables
		    var MovingCube;
		    var vaporAreaTemperatureLines=#{linesPlotsBean.vaporAreaTemperatureLines};
	        var liquidAreaLines=#{linesPlotsBean.liquidAreaTemperatureLines};
		    var liquidLinejson= #{linesPlotsBean.liquidLineJson};
		    var vaporLinejson = #{linesPlotsBean.vaporLineJson};
		    var vaporAreaPressureLines =#{linesPlotsBean.vaporAreaPressureLines};
		    var liquidAreaPressureLines = #{linesPlotsBean.liquidAreaPressureLines};

		    var plotType='enthalpy';
		    var xAxisLabel='Presión [Pa]';
		    var yAxisLabel='Entalpía [J/kmol]';
		    var zAxisLabel ='Temperatura [K]';

		    var temperatureLines={on:true};
		    var pressureLines ={on: true};

		    var linesObject=[];
			var textObjects=[];

			var axisLength;

			var mouse={x:0,y:0};
			var INTERSECTED, projector;
			var points = new THREE.Geometry();
			var parts;
		    
		    init();
		    animate();
		
		   function init(){
			   	MovingCube = new THREE.Object3D();
		        sceneCameraRenderer();
		        eventsControlsStats();
		        lightFloorSkybox();
		        debugaxis(1200);
		     // initialize object to perform world/screen calculations
		    	projector = new THREE.Projector();
		    	
				draw();

				// when the mouse moves, call the given function
				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
			    
			  	addEqHandler( "btn_add", 'enthalpy','Entalpía [J/kmol]' );
				addEqHandler( "btn_sub", 'entropy','Entropía [j/(kmol K)]' );
				addEqHandler( "btn_rsub", 'gibbs' ,'E. Gibbs [j/kmol]');

				addLinesHandler("btn_tempLines",temperatureLines);
				addLinesHandler("btn_pressure",pressureLines);
				  
		    }

		    function draw(){
		    	scene.remove(parts);
		    	points = new THREE.Geometry(); 
			    //points.vertices =[];
		    	linesObject.forEach(function(entry){
					scene.remove(entry);
					});

				textObjects.forEach(function(entry){
					scene.remove(entry);
				});
				
		    	var material = new THREE.LineBasicMaterial({
	                color: 0x0000ff
	            });
			    var redmaterial = new THREE.LineBasicMaterial({
	                color: 0xff0000
	            });
	           var jsonline= enthalpyLine(liquidLinejson);
	           var vaporJsonLine= enthalpyLine(vaporLinejson);

	           var jsonsLines =[jsonline,vaporJsonLine]; 
				var liquidLines=[jsonline];
				var vaporLines=[vaporJsonLine];

				
					liquidAreaLines.forEach(function(entry){
							var line = enthalpyLine(entry);
							jsonsLines.push(line);
							if(temperatureLines.on){
								liquidLines.push(line);
							}
							
						});
	
					
					vaporAreaTemperatureLines.forEach(function(entry){
							var line = enthalpyLine(entry);
							jsonsLines.push(line);
							if(temperatureLines.on){
								vaporLines.push(line);
							}
						});
				

				
					vaporAreaPressureLines.forEach(function(entry){
							var line=enthalpyLine(entry);
							jsonsLines.push(line);
							if(pressureLines.on){
								liquidLines.push(line);
							}
						});
	
					liquidAreaPressureLines.forEach(function(entry){
							var line =enthalpyLine(entry);
							jsonsLines.push(line);
							if(pressureLines.on){
								vaporLines.push(line);
							}
						});
				
				
	           normalizeVars(jsonsLines);

	           liquidLines.forEach(function(entry){
					createAndAddLineGeometry(entry ,0x0000ff);
		          });
	           vaporLines.forEach(function(entry){
	        	   createAndAddLineGeometry(entry ,0xff0000);
		           });	         	
	          drawAxisLabels();

	          drawPoints();
		    }

			function drawPoints(){
				
				
				var color = new THREE.Color( 0x00aa00 );
				var mat = new THREE.PointCloudMaterial( { size: 5,color:color } );
				
				 parts = new THREE.PointCloud( points, mat );
				scene.add(parts);
			}
		    
		   function addEqHandler( id, eq ,yLabel) {

				var el = document.getElementById( id );

				el.addEventListener( 'click', function () {

					plotType = eq;
					yAxisLabel = yLabel;	

					var l = document.getElementById("info");
					if(plotType === 'entropy'){
						l.innerHTML = "Temperatura-Entropía-Presión";
					}else if(plotType === 'gibbs'){
						l.innerHTML = "Temperatura-Gibbs-Presión";
					}else{
						l.innerHTML = "Temperatura-Entalpía-Presión";
					}				
					draw();
					
					document.getElementById( "btn_add" ).style.backgroundColor = "transparent";
					document.getElementById( "btn_sub" ).style.backgroundColor = "transparent";
					document.getElementById( "btn_rsub" ).style.backgroundColor = "transparent";

					el.style.backgroundColor = "darkorange";

				});

			}


		   function addLinesHandler( id, lines) {

				var el = document.getElementById( id );

				el.addEventListener( 'click', function () {

					lines.on = !lines.on;

					console.log(lines.on);
					console.log(temperatureLines.on);
					draw();
					
					if(lines.on){
						el.style.backgroundColor = "darkorange";
					}else{
						el.style.backgroundColor = "transparent";
					}

				});

			}


		    function enthalpyLine(jsonArrayPointInfo){
			    var jsonline=[];
	           for (var i = 0; i< jsonArrayPointInfo.length; i++) {
	        	   var yp =0;
	        	   
					if(plotType === 'entropy'){
						yp=jsonArrayPointInfo[i].entropy;
					}else if(plotType === 'gibbs'){
						yp=jsonArrayPointInfo[i].gibbs;
					}else{
						yp = jsonArrayPointInfo[i].enthalpy;
					}
						
		            
		              var position ={
				              	
		                        z :jsonArrayPointInfo[i].pressure,
		                        x: yp,
		                        y : jsonArrayPointInfo[i].temperature
		                      };

		              jsonline[i] = position;
		           };
		           
		           jsonline.userData=jsonArrayPointInfo;
		           return jsonline;
		    }
			/* function forLines(){
				 var material = new THREE.LineBasicMaterial({
				        color: 0x0000ff
				    });
				 var material2 = new THREE.LineBasicMaterial({
				        color: 0xff0000
				    });
				    
			    var jsonline1 = #{plotBean.lineJson};
			    var jsonline2 = #{plotBean.secondLineJson};

			    normalizeVars([jsonline1,jsonline2]);
			    createAndAddLineGeometry(jsonline1,material);
			    createAndAddLineGeometry(jsonline2,material2);
			    
			} */
		 
			function createAndAddLineGeometry(jsonline1,hexColor){
				var geometry = new THREE.Geometry();
				var particles=[];
	            for(var i = 0; i<jsonline1.length ; i++){
	                var x = jsonline1[i].x;
	                var y = jsonline1[i].y;
	                var z = jsonline1[i].z;
	                geometry.vertices.push(new THREE.Vector3(x,y,z));
	            

	                var vector = new THREE.Vector3(x,y,z);	                 	                  				
					var vectorData =jsonline1.userData[i];
					vector.userData = vectorData;
 					points.vertices.push(vector);					
					particles.push(vector); 
	               			         
	            }
	            var material = new THREE.LineBasicMaterial({
	                color: hexColor
	            });
	            var line = new THREE.Line(geometry, material);
	            line.name='name';
	            line.userData = particles;

	            
	            linesObject.push(line);
	            //console.log('lineadded');
	            scene.add(line);
			}
		    

		    function normalizeAndAddGeometries(jsons,materials){
		    	normalizeVars(jsons);
	        	createAndAddGeometries(jsons,materials);
		    }

			function createAndAddGeometries(jsons,materials){
				jsons.forEach(function(json,index){
					createAndAddGeometry(json,materials[index]);
				});
			}
		    
		    function createAndAddGeometry(json,material){
		    	var geometry = new THREE.Geometry();
	            for(var i = 0; i<json.length ; i++){
	                var x = json[i].x;
	                var y = json[i].y;
	                var z = json[i].z;
	                geometry.vertices.push(new THREE.Vector3(x,y,z));			         
	            }
	            var n = Math.sqrt( json.length);
	            for(var i = 0; i < n-1;i++){
	                for(var j = 0; j <n-1;j++){
	                    var index = n*i +j;
	                    geometry.faces.push(new THREE.Face3(index,index+1,n+index));
	                    geometry.faces.push(new THREE.Face3(index+1,index+n+1,index+n));
	                }
	            }	
	            geometry.mergeVertices()
		        geometry.computeFaceNormals();
	            geometry.computeVertexNormals();	            
		        var mesh = new THREE.Mesh(geometry, material);

		        MovingCube.add(mesh);
		        scene.add(mesh);		
	            
		    }
	
	
	
			function sceneCameraRenderer(){
			     // SCENE
			    scene = new THREE.Scene();
			    // CAMERA
			    var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;
			    var VIEW_ANGLE = 45, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 20000;
			    camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);
			    
			    camera.position.set(500,-2000,1000);
			    camera.up = new THREE.Vector3( 0, 0, 1 );
			    
			    scene.add(camera);

			    
			    camera.lookAt(scene.position);

			    
			    // RENDERER
			    if ( Detector.webgl )
			        renderer = new THREE.WebGLRenderer( {antialias:true} );
			    else
			        renderer = new THREE.CanvasRenderer(); 
			    renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
			    container = document.getElementById( 'ThreeJS' );
			    container.appendChild( renderer.domElement );
			}
			function eventsControlsStats(){
			    // EVENTS
			    THREEx.WindowResize(renderer, camera);
			    THREEx.FullScreen.bindKey({ charCode : 'm'.charCodeAt(0) });
			    // CONTROLS
			    //controls = new THREE.TrackballControls(camera,renderer.domElement);
			    //controls = new THREE.OrbitControls( camera, renderer.domElement );
			    
			     controls = new THREE.OrbitControls( camera,renderer.domElement );
				controls.damping = 0.2;
			    // STATS
			    stats = new Stats();
			    stats.domElement.style.position = 'absolute';
			    stats.domElement.style.top = '0px';
			    stats.domElement.style.right='0px';
			    stats.domElement.style.zIndex = 100;
			    container.appendChild( stats.domElement );
			}
			function animate(){
			    requestAnimationFrame( animate );
			    render();  
			    update();     
			    controls.update();
			    stats.update();
			}

			function update()
			{
				
				// create a Ray with origin at the mouse position
				//   and direction into the scene (camera direction)
				var vector = new THREE.Vector3( mouse.x, mouse.y, 1 );
				projector.unprojectVector( vector, camera );
				var ray = new THREE.Raycaster( camera.position, vector.sub( camera.position ).normalize() );

				// create an array containing all objects in the scene with which the ray intersects
				var intersects = ray.intersectObjects( linesObject );

				// INTERSECTED = the object in the scene currently closest to the camera 
				//		and intersected by the Ray projected from the mouse position 	
				
				// if there is one (or more) intersections
				if ( intersects.length > 0 )
				{
					// if the closest object intersected is not the currently stored intersection object
					if ( intersects[ 0 ].object != INTERSECTED ) 
					{
					    // restore previous intersection object (if it exists) to its original color
						if ( INTERSECTED ) 
							INTERSECTED.material.color.setHex( INTERSECTED.currentHex );
						// store reference to closest object as current intersection object
						INTERSECTED = intersects[ 0 ].object;
						// store color of closest object (for later restoration)
						INTERSECTED.currentHex = INTERSECTED.material.color.getHex();
						// set a new color for closest object
						INTERSECTED.material.color.setHex( 0xffff00 );

						
						// update text, if it has a "name" field.
						if ( intersects[ 0 ].object.name )
						{
							console.log(intersects[ 0 ].object);
							
						    //context1.clearRect(0,0,640,480);
							//var message = intersects[ 0 ].object.name;
						//	var metrics = context1.measureText(message);
							//var width = metrics.width;
							/* context1.fillStyle = "rgba(0,0,0,0.95)"; // black border
							context1.fillRect( 0,0, width+8,20+8);
							context1.fillStyle = "rgba(255,255,255,0.95)"; // white filler
							context1.fillRect( 2,2, width+4,20+4 );
							context1.fillStyle = "rgba(0,0,0,1)"; // text color
							context1.fillText( message, 4,20 );
							texture1.needsUpdate = true; */
							
						}
						else
						{
							//context1.clearRect(0,0,300,300);
							//texture1.needsUpdate = true;
						}
					}
				} 
				else // there are no intersections
				{
					// restore previous intersection object (if it exists) to its original color
					if ( INTERSECTED ) 
						INTERSECTED.material.color.setHex( INTERSECTED.currentHex );
					// remove previous intersection object reference
					//     by setting current intersection object to "nothing"
					INTERSECTED = null;
					//context1.clearRect(0,0,300,300);
					//texture1.needsUpdate = true;
				}

				
				controls.update();
				stats.update();
			}
	
		
	
			function render() 
			{
			    renderer.render( scene, camera );
			}
	
	
			function lightFloorSkybox(){
				//scene.add( new THREE.AmbientLight( 0xffffff ) );
			    // LIGHT
			    var light = new THREE.PointLight(0xffffff);
			    light.position.set(0,0,2500);
			    light.castShadow =true;
	
			    var light2 = new THREE.PointLight(0xffffff);
			    light2.position.set(2500,2500,2500);
			    light2.castShadow =true;
			    

			    var light3 = new THREE.PointLight(0xffffff);
			    light3.position.set(-300,-300,100);
			    light3.castShadow =true;
			    scene.add(light3);
			    
		

			    /* var sprite = new THREE.Sprite( new THREE.SpriteCanvasMaterial( { color: 0xff0040 } ) );
			    light.add( sprite ); */
				scene.add(light2);
			    scene.add(light);
			    
			    // FLOOR
			    
			    var wireframeMaterial = new THREE.MeshBasicMaterial( { color: 0x555555, wireframe: true, side:THREE.DoubleSide } ); 
			    var floorGeometry = new THREE.PlaneGeometry(1500, 1500, 10, 10);
			    var floor =new THREE.Mesh(floorGeometry, wireframeMaterial);
			    //floor.position.z = 1000;
			    floor.position.x=500;
			    floor.position.y=500;
			    //floor.rotation.x = Math.PI / 2;
			    scene.add(floor);
			    // SKYBOX/FOG
			    var skyBoxGeometry = new THREE.BoxGeometry( 10000, 10000, 10000 );
			    var skyBoxMaterial = new THREE.MeshBasicMaterial( { color: 0xdddddd, side: THREE.BackSide } );
			    var skyBox = new THREE.Mesh( skyBoxGeometry, skyBoxMaterial );
			     scene.add(skyBox);
			    //scene.fog = new THREE.FogExp2( 0x9999ff, 0.00025 );
			}
			function slope(min,max){
            	return 1000/(max-min);
            }

		    function normalizeVars(jsons){
		    	var minX = jsons[0][0].x;
		    	var maxX = jsons[0][0].x;

		    	var minY = jsons[0][0].y;
		    	var maxY = jsons[0][0].y;

				var minZ = jsons[0][0].z;
		    	var maxZ = jsons[0][0].z;

		    	jsons.forEach(function(json,index){
		    		for(var i =0; i< json.length;i++){
		    			var position = json[i];
		    			if(position.x<minX){
		    				minX=position.x;
		    			}if(position.x>maxX){
		    				maxX=position.x;
		    			}if(position.y<minY){
		    				minY=position.y;
		    			}if(position.y>maxY){
		    				maxY=position.y;
		    			}if(position.z<minZ){
		    				minZ=position.z;
		    			}if(position.z>maxZ){
		    				maxZ=position.z;
		    			}
		    		}
		    	});
		    	var m = slope(minX,maxX);
		    	var ym= slope(minY,maxY);
		    	var zm=slope(minZ,maxZ);
		    	jsons.forEach(function(json,index){
		    		for(var i =0;i<json.length;i++){
		    			var position = json[i];		    			
		    			var newX = (position.x-minX)*m;
		    			var newY = (position.y-minY)*ym;
		    			var newZ =(position.z-minZ)*zm;
		    			position.x=newX;
		    			position.y=newY;
		    			position.z=newZ;
		    		}
		    	});
		    }
	
			function debugaxis(aLen){
				axisLength = aLen;
				 createAxis(v(0, 0, 0), v(axisLength, 0, 0), 0xFF0000);
			    createAxis(v(0, 0, 0), v(0, axisLength, 0), 0x00FF00);
			    createAxis(v(0, 0, 0), v(0, 0, axisLength), 0x0000FF);
			};
			function v(x,y,z){ 
	            return new  THREE.Vector3(x,y,z); 
	    	}

			function createAxis(p1, p2, color){
				//console.log("createAxis");
	            var line, lineGeometry = new THREE.Geometry(),
	            lineMat = new THREE.LineBasicMaterial({color: color, lineWidth: 2});
	            lineGeometry.vertices.push(p1, p2);
	            line = new THREE.Line(lineGeometry, lineMat);
	            scene.add(line);
	            //console.log("line added");
	   		 }

			function drawAxisLabels(){
				 addText(
					    	{x:axisLength/4,y:-100,z:0},
					    	{x:Math.PI / 2,y:0,z:0},
					    	xAxisLabel);

				    addText(
				    	{y:400+axisLength/1.8,x:-100,z:0},
				    	{x:Math.PI / 2,y:-Math.PI/2,z:0},
				    	yAxisLabel);
				    addText(
				    	{x:-50,y:-50,z:axisLength/4},
				    	{x:Math.PI / 2,y:-Math.PI/4,z:Math.PI/2},
				    	zAxisLabel);
				    
			}

			function addText(position,rotation,theText){
				
				var text3d = new THREE.TextGeometry( theText, {
					size: 90,
					height: 20,
					curveSegments: 3,
					font: "ubuntu"

				});

				text3d.computeBoundingBox();
				var centerOffset = -0.5 * ( text3d.boundingBox.max.x - text3d.boundingBox.min.x );

				//var textMaterial = new THREE.MeshBasicMaterial( { color: 0x8B4500, overdraw: 0.5 } );
				var textMaterial =new THREE.MeshPhongMaterial( { 
		            color: 0x8B4500, 
		            ambient: 0x2200ee, // should generally match color
		            specular: 0x050505,
		            side: THREE.DoubleSide,
		            shininess: 100
		        } ) ;

				
				text = new THREE.Mesh( text3d, textMaterial );

				//text.position.x = centerOffset;
				text.position.x = position.x;
				text.position.y = position.y ;
				text.position.z = position.z;

				text.rotation.x = rotation.x;
				text.rotation.y = rotation.y;
				text.rotation.z = rotation.z;

				textObjects.push(text);
				scene.add( text );
			}
	
			 function onDocumentMouseMove( event ){
				// the following line would stop any other event handler from firing
				// (such as the mouse's TrackballControls)
				// event.preventDefault();

				// update sprite position
				//sprite1.position.set( event.clientX, event.clientY - 20, 0 );
				
				// update the mouse variable
				mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
				//entconsole.log("onDocumentMouseMove, mouseposition("+mouse.x+","+mouse.y+")");
			} 
			

	
			//]]>
		    </script>
						 
		</ui:insert>
	</h:body> 
</html>